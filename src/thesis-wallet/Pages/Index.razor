@page "/"
@inject IJSRuntime jsRuntime;
@inject IEthereumHostProvider _ethereumHostProvider;
@inject NethereumAuthenticator  _nethereumAuthenticator;
@using Nethereum.ABI.FunctionEncoding
@using Nethereum.Contracts
@using Nethereum.Hex.HexTypes;
@using System.IO
@using System.Text.Json;
@using System.Text.Json.Serialization;
@using Nethereum.Web3
@using Newtonsoft.Json
@using Newtonsoft.Json.Linq
@using System.Text
@using System.Xml.Serialization
@using System.Xml
@using System.Collections
@using System.Threading


@if (EthereumAvailable == true && !string.IsNullOrEmpty(menu.SelectedAccount)) {
    <MatDialog @bind-IsOpen="@menu.existingDialogIsOpen">
        <MatDialogTitle>Join existing contract</MatDialogTitle>
        <MatDialogContent>
            <p>Das Contract address</p>
            <MatTextField Outlined="true" @bind-Value="@menu.dasContractAddress" style="width:30em;"></MatTextField>
            <p>Das Contract Form file (xml)</p>
            <InputFile OnChange="menu.LoadFilesDialog" accept=".xml" />
        </MatDialogContent>
        <MatDialogActions>
            <MatButton OnClick="@menu.CancelExistingContractDialog">Cancel</MatButton>
            <MatButton OnClick="@menu.SubmitExistingContractDialog">Add</MatButton>
        </MatDialogActions>
    </MatDialog>
    <div class="mat-layout-grid">
        <div class="mat-layout-grid-inner">
            <div class="mat-layout-grid-cell mat-layout-grid-cell-span-3">
                <div class="mat-layout-grid-inner">
                    <div class="mat-layout-grid-cell mat-layout-grid-cell-align-middle mat-layout-grid-cell-span-4">
                        <div style="display:flex;justify-content:center;">
                            <MatFAB Icon="@MatIconNames.Home" Raised="true" OnClick="@menu.LoadDashboard"></MatFAB>
                        </div>
                        <div style="display:flex;justify-content:center;">
                            <MatButtonLink Href="" Style="font-size:0.8em" OnClick="@menu.LoadDashboard">Dashboard</MatButtonLink>
                        </div>
                    </div>
                    <div class="mat-layout-grid-cell mat-layout-grid-cell-span-4">
                        <div style="display:flex;justify-content:center;">
                            <MatFAB Icon="@MatIconNames.Note_add" Raised="true"></MatFAB>
                        </div>
                        <div style="display:flex;justify-content:center;">
                            <MatButtonLink Href="" Style="font-size:0.8em">New contract</MatButtonLink>
                        </div>
                    </div>
                    <div class="mat-layout-grid-cell mat-layout-grid-cell-span-4">
                        <div style="display:flex;justify-content:center;">
                            <MatFAB Icon="@MatIconNames.Pageview" Raised="true" OnClick="@menu.OpenExistingContractDialog"></MatFAB>
                        </div>
                        <div style="display:flex;justify-content:center;">
                            <MatButtonLink Href="" Style="font-size:0.8em" OnClick="@menu.OpenExistingContractDialog">Join existing</MatButtonLink>
                        </div>
                    </div>
                </div>
                <br />
                <MatDivider></MatDivider>
                <MatH5 Style="text-align:center;line-height:110%;padding-top:0.2em">Contract list</MatH5>
                <MatDivider></MatDivider>
                <MatTreeView TNode="TreeNodeModel" IsNodeExpandedCallback="@menu.ItemIsExpanded" RootNodes="@menu.ViewRoots" GetChildNodesCallback="@((n)=>n.Nodes)" @bind-SelectedNode="@menu.SelectedNode" @bind-SelectedNode:event="SelectedNodeChanged">
                    <NodeTemplate>
                        @context.Name
                    </NodeTemplate>
                </MatTreeView>
            </div>
            <div class="mat-layout-grid-cell mat-layout-grid-cell-span-9">
                @if (menu != null && menu.SelectedNode != null && menu.SelectedNode.Form != null) {
                    <CascadingValue Value="@menu.SelectedNode">
                        <CascadingValue Value="@menu.SelectedNode.Form">
                            <DForm @ref="menu.dForm"></DForm>
                        </CascadingValue>
                    </CascadingValue>
            } else {
                    <span>Dashboard goes here</span>
                }
            </div>
        </div>
    </div>
} else {
     <Metamask />
}


@code{
    DasContractMenu menu = new DasContractMenu();
    bool EthereumAvailable { get; set; }
    string BlockHash { get; set; }
    string TransactionHash { get; set; }
    string ErrorTransferMessage { get; set; }
    protected string AuthenticatedAccount { get; set; }

    protected override async Task OnInitializedAsync() {
        _ethereumHostProvider.SelectedAccountChanged += AccountChanged;
        EthereumAvailable = await _ethereumHostProvider.CheckProviderAvailabilityAsync();
        menu.w3 = await _ethereumHostProvider.GetWeb3Async();
    }

    private async Task AccountChanged(string account) {
        menu.SelectedAccount = account;
        menu.LoadFormData(menu.SelectedNode);
        await this.InvokeAsync(StateHasChanged);
    }

    protected async Task GetBlockHashAsync() {
        var web3 = await _ethereumHostProvider.GetWeb3Async();
        var block = await web3.Eth.Blocks.GetBlockWithTransactionsByNumber.SendRequestAsync(new HexBigInteger(1));
        BlockHash = block.BlockHash;
    }

    protected async Task TransferEtherAsync() {
        try {
            string smartContractAddress = "0xCc838408bF5B77b60970b60F4F5c977b1f11F514";
            string abiStandardToken = @"[{""constant"":true,""inputs"":[{""internalType"":""uint256"",""name"":"""",""type"":""uint256""}],""name"":""adopters"",""outputs"":[{""internalType"":""address"",""name"":"""",""type"":""address""}],""payable"":false,""stateMutability"":""view"",""type"":""function""},{""constant"":false,""inputs"":[{""internalType"":""uint256"",""name"":""petId"",""type"":""uint256""}],""name"":""adopt"",""outputs"":[{""internalType"":""uint256"",""name"":"""",""type"":""uint256""}],""payable"":false,""stateMutability"":""nonpayable"",""type"":""function""},{""constant"":true,""inputs"":[],""name"":""getAdopters"",""outputs"":[{""internalType"":""address[16]"",""name"":"""",""type"":""address[16]""}],""payable"":false,""stateMutability"":""view"",""type"":""function""}]";
            var web3 = await _ethereumHostProvider.GetWeb3Async();
            var contract = web3.Eth.GetContract(abiStandardToken, smartContractAddress);
            var contractHandler = web3.Eth.GetContractHandler(smartContractAddress);
            Console.WriteLine(contractHandler.EthApiContractService.GetCode.ToString());
            Function adoptapet = contract.GetFunction("adopt");
            object[] paramser = new object[1]{ 3 };
            var transactionHash = await adoptapet.SendTransactionAsync(menu.SelectedAccount, new HexBigInteger(63721), null, paramser);
            Console.WriteLine(transactionHash);
        } catch (Exception ex) {
            ErrorTransferMessage = ex.Message;
        }
    }

    /* MENU */
    public class TreeNodeModel {
        private DasContractMenu Menu { get; set; }
        public string Name { get; set; }
        public DasContractItem DasContractItem { get; set; }
        public Form Form { get; set; }
        public List<TreeNodeModel> Nodes { get; set; } = new List<TreeNodeModel>();
        public bool IsExpanded { get; set; } = true;
        public string MyETHAddress { get; set; }
        public Web3 w3 { get; set; }

        public TreeNodeModel(string name, string address = null, Web3 w = null, DasContractMenu menu = null, DasContractItem contract = null, Form form = null) {
            Menu = menu;
            w3 = w;
            Name = name;
            DasContractItem = contract;
            Form = form;
        }

        public async void SubmitSmartContractFunction() {
            Contract contract = w3.Eth.GetContract(DasContractItem.DasContract.ABI, DasContractItem.ContractAddress);
            JArray callableFunctions = JArray.Parse(DasContractItem.DasContract.ABI);
            JObject desiredFunc = null;
            foreach (JObject callableFunction in callableFunctions) {
                if (callableFunction["name"]?.ToString() == Form.FuncBind) {
                    desiredFunc = callableFunction;
                }
            }
            if (desiredFunc == null) {
                Console.WriteLine($"Unable to submit form {Form.Label} because the function {Form.FuncBind} does not exist in the smart contract.");
                return;
            }
            List<object> inputs = new List<object>();
            foreach (var input in ((JArray)desiredFunc["inputs"])) {
                string toSearchFor = input["name"].ToString();
                bool found = false;
                foreach (FieldGroup fieldGroup in Form.FieldGroups) {
                    foreach (Field field in fieldGroup.Fields) {
                        if (field.ParamBind == toSearchFor) {
                            inputs.Add(field.GetData());
                            found = true;
                            break;
                        }
                    }
                    if (found) {
                        break;
                    }
                }
                if (!found) {
                    Console.WriteLine($"Unable to submit form {Form.Label} because the parameter {toSearchFor} was not provided for the function {Form.FuncBind}.");
                    return;
                }
            }
            Function contractTransaction = contract.GetFunction(Form.FuncBind);
            object[] paramsToCall = Menu.ParametersToObjectField(inputs);
            string transactionHash = await contractTransaction.SendTransactionAsync(MyETHAddress, paramsToCall);
            var receipt = await w3.Eth.Transactions.GetTransactionReceipt.SendRequestAsync(transactionHash);
            while (receipt == null){
                Thread.Sleep(1000);
                receipt = await w3.Eth.Transactions.GetTransactionReceipt.SendRequestAsync(transactionHash);
            }
            Menu.LoadFormData(Menu.SelectedNode);
        }
    }

    public class DasContractItem {        
        public string ContractAddress { get; set; }
        public DContract DasContract { get; set; }

        public DasContractItem(string contractForm, string other, bool deploy) {
            using (TextReader reader = new StringReader(contractForm)) {
                XmlSerializer serializer = create_throwing_serializer();
                XmlReader xmlreader = new XmlTextReader(reader);
                try {
                    DasContract = (DContract)serializer.Deserialize(xmlreader);
                } catch (Exception e) {
                    Console.WriteLine("Error parsing XML!\n" + $"Error:\n{e.Message}\n{e.StackTrace}");
                    return;
                }
            }
            if (deploy) {                
                ContractAddress = "";
            } else {
                ContractAddress = other;                
            }
        }
        
        private void Serializer_Throw(object sender, XmlElementEventArgs e) {
            throw new Exception("XML format exception.");
        }
        private void Serializer_Throw(object sender, XmlAttributeEventArgs e) {
            throw new Exception("XML format exception.");
        }
        private void Serializer_Throw(object sender, XmlNodeEventArgs e) {
            throw new Exception("XML format exception.");
        }
        
        private XmlSerializer create_throwing_serializer() {
            XmlSerializer serializer = new XmlSerializer(typeof(DContract));
            serializer.UnknownAttribute += new XmlAttributeEventHandler(Serializer_Throw);
            serializer.UnknownElement += new XmlElementEventHandler(Serializer_Throw);
            serializer.UnknownNode += new XmlNodeEventHandler(Serializer_Throw);
            return serializer;
        }
    }

    public class DasContractMenu {
        public DForm dForm { get; set; }
        public Web3 w3 { get; set; }
        public List<TreeNodeModel> ViewRoots { get; set; } = new List<TreeNodeModel>();
        private TreeNodeModel selectedNode;
        public TreeNodeModel SelectedNode {
            get {
                return selectedNode;
            }
            set {
                if (value?.Form != null) {
                    selectedNode = value;
                    LoadFormData(selectedNode);
                } else if (value != null) {
                    value.IsExpanded = !value.IsExpanded;
                }
            }
        }
        public List<DasContractItem> availableContracts = new List<DasContractItem>();
        public bool existingDialogIsOpen = false;
        public bool newDialogIsOpen = false;
        public string dasContractBytecode = "";
        public string dasContractAddress = "";
        public string dasFormFile = "";
        public string SelectedAccount = "";

        public async void LoadFormData(TreeNodeModel item) {
            if (item == null) {
                return;
            }

            foreach (FieldGroup fieldGroup in item.Form.FieldGroups) {
                foreach (Field field in fieldGroup.Fields) {
                    if (!String.IsNullOrEmpty(field.ViewBind)) {
                        string fixated = "fixated:";
                        if (field.ViewBind.Substring(0, fixated.Length) == fixated) {
                            string remainder = field.ViewBind.Substring(fixated.Length);
                            if (remainder == "myAccountAddress") {
                                field.SetData(SelectedAccount);
                            } else if (remainder == "myContractAddress") {
                                field.SetData(item.DasContractItem.ContractAddress);
                            } else {
                                field.SetData(remainder);
                            }
                        } else {
                            Contract contract = w3.Eth.GetContract(item.DasContractItem.DasContract.ABI, item.DasContractItem.ContractAddress);
                            ViewToken tokenized = TokenizeCall(field.ViewBind);
                            Function dataView = contract.GetFunction(tokenized.FuncName);
                            
                            List<object> inputs = new List<object>();
                            inputs.AddRange(tokenized.Parameters);
                            object[] paramsToCall = ParametersToObjectField(inputs);
                            List<ParameterOutput> retValues = await dataView.CallDecodingToDefaultAsync(paramsToCall);

                            List<string> output = OutputFromResult(retValues, tokenized, field);
                            if (output.Count == 1) {
                                field.SetData(output[0]);
                            } else {
                                field.SetDataList(output);
                            }
                        }
                    }
                }
            }
            dForm.refresh();
        }

        private List<string> OutputFromResult(List<ParameterOutput> retValues, ViewToken tokenized, Field field) {
            List<string> output = new List<string>();
            List<ParameterOutput> outputsToProcess = new List<ParameterOutput>();
            if (!String.IsNullOrEmpty(tokenized.Property)) {                
                foreach (ParameterOutput retValue in retValues) {
                    if (retValue.Parameter.Name == tokenized.Property) {
                        outputsToProcess.Add(retValue);
                        break;
                    }    
                }
            } else {
                outputsToProcess.AddRange(retValues);
            }

            if (outputsToProcess.Count == 1) {
                ParameterOutput singleReturn = outputsToProcess[0];
                if (IsIterable(singleReturn.Parameter.DecodedType)) {
                    List<object> resArray = (List<object>)singleReturn.Result;
                    if (tokenized.Index >= 0) {
                        if (resArray.Count > tokenized.Index) {
                            output.Add(resArray[tokenized.Index].ToString());
                        } else {
                            Console.WriteLine($"Ignoring field {field.Label}. Index out of bounds for array retrieved from {field.ViewBind}!");
                        }                                            
                    } else {
                        foreach (object res in resArray) {
                            output.Add(res.ToString());
                        }
                    }
                } else {
                    output.Add(singleReturn.Result.ToString());
                }
            } else {
                if (tokenized.Index >= 0) {
                    if (outputsToProcess.Count > tokenized.Index) {
                        ParameterOutput singleReturn = outputsToProcess[tokenized.Index];
                        if (IsIterable(singleReturn.Parameter.DecodedType)) {
                            List<object> resArray = (List<object>)singleReturn.Result;
                            foreach (object res in resArray) {
                                output.Add(res.ToString());
                            }
                        } else {
                            output.Add(singleReturn.Result.ToString());
                        }
                    } else {
                        Console.WriteLine($"Ignoring field {field.Label}. Index out of bounds for parameter order from {field.ViewBind}!");
                    }   
                } else {
                    foreach (ParameterOutput singleReturn in outputsToProcess) { 
                        if (IsIterable(singleReturn.Parameter.DecodedType)) {
                            List<object> resArray = (List<object>)singleReturn.Result;
                            foreach (object res in resArray) {
                                output.Add(res.ToString());
                            }
                        } else {
                            output.Add(singleReturn.Result.ToString());
                        }
                    }
                }
            }

            return output;            
        }

        private string TokenizeParams(ViewToken token, string prepend, string format) {
            if (format == ")") {
                return prepend;
            }

            string[] second = format.Split(')');
            foreach (string funcParam in second[0].Split(',')) {
                token.Parameters.Add(funcParam);
            }
            if (second.Length == 1) {
                return prepend;
            }
            return prepend + second[1];    
        }

        private string TokenizeProperty(ViewToken token, string prepend, string format) {
            string[] third = format.Split('[');
            if (third.Length == 1) {
                token.Property = format;
                return prepend;
            }
            token.Property = third[0];
            return prepend + '[' + third[1];
        }

        private ViewToken TokenizeCall(string format) {
            format = format.Replace(" ", String.Empty);
            ViewToken token = new ViewToken();

            string[] first = format.Split('(');
            if (first.Length == 2) {
                format = TokenizeParams(token, first[0], first[1]);
            }

            string[] second = format.Split('.');
            if (second.Length == 2) {
                format = TokenizeProperty(token, second[0], second[1]);
            }

            string[] third = format.Split('[');
            if (third.Length == 2) {
                token.FuncName = third[0];
                string indexer = third[1].Replace("]", String.Empty);
                token.Index = Convert.ToInt32(indexer);                
            } else {
                token.FuncName = format;
            }

            return token;
        }

        public object[] ParametersToObjectField(List<object> parameters) {
            for (int i = 0; i < parameters.Count; ++i) {
                object res = parameters[i];
                try {
                    Int64 serializedRes = Convert.ToInt64(res);
                    parameters[i] = serializedRes;
                } catch (Exception e) {
                    continue;
                }
                try {
                    UInt64 serializedRes = Convert.ToUInt64(res);
                    parameters[i] = serializedRes;
                } catch (Exception e) {
                    continue;
                }
            }
            var result = parameters.Cast<object>().ToArray();
            return result;
        }

        private bool IsIterable(Type type) {
            return typeof(IEnumerable).IsAssignableFrom(type) && type != typeof(string);
        }
    
        public void LoadDashboard() {
            selectedNode = null;
        }

        public bool ItemIsExpanded(TreeNodeModel model) {
            return model.IsExpanded;
        }

        public void OpenExistingContractDialog() {
            existingDialogIsOpen = true;
        }
 
        public void SubmitExistingContractDialog() {
            DasContractItem item = new DasContractItem(dasFormFile, dasContractAddress, false);
            availableContracts.Add(item);            
            TreeNodeModel root = new TreeNodeModel(item.DasContract.Name);

            foreach (Form form in item.DasContract.Forms) {
                root.Nodes.Add(new TreeNodeModel(form.Label, SelectedAccount, w3, this, item, form));
            }
            ViewRoots.Add(root);

            existingDialogIsOpen = false;
            dasContractBytecode = "";
            dasContractAddress = "";
        }

        public void CancelExistingContractDialog() {
            existingDialogIsOpen = false;
            dasContractBytecode = "";
            dasContractAddress = "";
        }

        public async Task LoadFilesDialog(InputFileChangeEventArgs e) {
            try {
                foreach (var file in e.GetMultipleFiles(1)) {
                    using var reader = new StreamReader(file.OpenReadStream(100*1024));
                    dasFormFile = await reader.ReadToEndAsync();
                }
            } catch (Exception ex) {
                Console.WriteLine(ex.Message);
            }
        }   
    }

    class ViewToken {
        public string FuncName { get; set; } = "";
        public List<string> Parameters { get; set; } = new List<string>();
        public string Property { get; set; } = "";
        public int Index { get; set; } = -1;
    }
}